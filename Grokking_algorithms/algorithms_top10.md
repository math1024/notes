[TOC]



* from geek time 数据结构与算法之美

#### 数据结构

* 数组

  * 数组下标从0开始，历史习惯、减少一次减法运算,数组可以有些存放基础类型、

  * 先标记再删除

    数组根据下标查找 时间复杂度是O(1)

* 链表

  * 单链表
  * 双向链表、循环链表、双向循环链表
  * 实例：LRU、回文
  * tips
    * **指针或引用的含义：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量**
    * 插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏
    * 添加哨兵简化代码
    * 边界条件
      * 如果链表为空时，代码是否能正常工作？
      * 如果链表只包含一个结点时，代码是否能正常工作？
      * 如果链表只包含两个结点时，代码是否能正常工作？
      * 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
    * 画图、多加练习
  * 实例：单链表反转、链表中环的检测、两个有序的链表合并删除、链表倒数第 n 个结点、求链表的中间结点

* 栈

  * 数组实现-顺序栈、链表实现-链式栈
  * 讨论空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间
  * 实例：括号匹配、表达式求值、浏览器前进后退功能模拟，两个栈或双向链表

* 队列

  * 同样数组实现-顺序队列、链表实现-链式队列，数据搬移操作引用循环队列
  * 循环队列的实现注意队满`(tail+1)%n=head`和队空`head == tail`的判断
  * 阻塞队列 生产者-消费者
  * 并发队列
  * 对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队，注意队列的长度

* 散列表

  * 开放寻址、链表

  * 示例

    * 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？

      遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。

      如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。

      有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？

      以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。

  * 多次扩容，均摊开销

  * 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

  * LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突

* 二叉树

  * 满二叉树、完全二叉树（数组存）
  * 链表或数组存储
  * 卡特兰数
  * 散列表与二叉树的优劣
  * 递归求树的高度，广度遍历需要添加标记

* 堆

  * 小顶堆、大顶堆
  * TopK、优先级队列

* 跳表、

* 图

  * 有向图、无向图、带权
  * 邻接矩阵、邻接表


#### 算法

* 递归
  * 循环体、子问题、终止条件
  * 需要注意的两个问题：堆栈溢出、重复计算，同时也应注意空间复杂度的增长
  * 限制递归深度，重写调用栈
* 排序
  * 如何分析排序算法
    * 执行效率
    * 内存消耗
    * 稳定性
  * 有序度
  * 冒泡排序、插入排序、选择排序、希尔排序
* 二分查找
  * 有序数组，比较耗时多更适宜
  * 循环退出条件<=、mid 的取值 low +( (high - low )>>2)，low 和 high 的更新 +1
  * 数据过少体现不出优势，数据过多时对内存空间要求也高
* 跳表
  * 
* 搜索、
* 哈希算法、
* 贪心算法
  * 满足限制值时，期望值最大
  * 区间覆盖 每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法
* 分治算法
  * 分治算法是一种处理问题的思想，递归是一种编程技巧
    * 原问题与分解成的小问题具有相同的模式；
    * 原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法；
    * 具有分解终止条件，也就是说，当问题足够小时，可以直接求解；可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。
* 回溯算法
  * 回溯算法本质上就是枚举，优点在于其类似于摸着石头过河的查找策略，且可以通过剪枝少走冤枉路。它可能适合应用于缺乏规律，或我们还不了解其规律的搜索场景中。
* 动态规划
  * 动态规划是一种空间换时间的解决思路
  * 多阶段决策最优解模型，最优子结构、无后效性和重复子问题
  * 解决动态规划问题，一般有两种思路。我把它们分别叫作，状态转移表法和状态转移方程法
    * 状态转移表法解题思路大致可以概括为，回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码。
    * 状态转移方程法的大致思路可以概括为，找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。
  * 莱文斯坦距离（Levenshtein distance）和最长公共子串长度（Longest common substring length）。其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作。莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小
* 字符串匹配算法
  * Brute Force $O(n*m)$ Rabin-Karp $O(n)$ 有可能退化成$O(n*m)$ 
  * BM（Boyer-Moore）
  * KMP
* Trie 树
* AC自动机
* A*
* 

#### Tips

* 拓扑排序：凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决

#### 复杂度

* 时间复杂度
  * 最坏
  * 最好
  * 平均
* 空间复杂度
* 均摊复杂度

#### 应用实例

* redis数组结构
  * 压缩列表（可以看作一种特殊的数组）、有序数组、链表、散列表、跳表

