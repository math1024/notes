[TOC]



* from geek time 数据结构与算法之美

#### 数据结构

* 数组

  * 数组下标从0开始，历史习惯、减少一次减法运算,数组可以有些存放基础类型、

  * 先标记再删除

    数组根据下标查找 时间复杂度是O(1)

* 链表

  * 单链表
  * 双向链表、循环链表、双向循环链表
  * 实例：LRU、回文
  * tips
    * **指针或引用的含义：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量**
    * 插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏
    * 添加哨兵简化代码
    * 边界条件
      * 如果链表为空时，代码是否能正常工作？
      * 如果链表只包含一个结点时，代码是否能正常工作？
      * 如果链表只包含两个结点时，代码是否能正常工作？
      * 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
    * 画图、多加练习
  * 实例：单链表反转、链表中环的检测、两个有序的链表合并删除、链表倒数第 n 个结点、求链表的中间结点

* 栈

  * 数组实现-顺序栈、链表实现-链式栈
  * 讨论空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间
  * 实例：括号匹配、表达式求值、浏览器前进后退功能模拟，两个栈或双向链表

* 队列

  * 同样数组实现-顺序队列、链表实现-链式队列，数据搬移操作引用循环队列
  * 循环队列的实现注意队满`(tail+1)%n=head`和队空`head == tail`的判断
  * 阻塞队列 生产者-消费者
  * 并发队列
  * 对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队，注意队列的长度

* 散列表

  * 开放寻址、链表

  * 示例

    * 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？

      遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。

      如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。

      有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？

      以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。

  * 多次扩容，均摊开销

  * 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

  * LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突

* 二叉树

  * 满二叉树、完全二叉树（数组存）
  * 链表或数组存储
  * 卡特兰数
  * 散列表与二叉树的优劣
  * 递归求树的高度，广度遍历需要添加标记

* 堆、

* 跳表、

* 图、

* Trie 树

#### 算法

* 递归
  * 循环体、子问题、终止条件
  * 需要注意的两个问题：堆栈溢出、重复计算，同时也应注意空间复杂度的增长
  * 限制递归深度，重写调用栈
* 排序
  * 如何分析排序算法
    * 执行效率
    * 内存消耗
    * 稳定性
  * 有序度
  * 冒泡排序、插入排序、选择排序、希尔排序
* 二分查找
  * 有序数组，比较耗时多更适宜
  * 循环退出条件<=、mid 的取值 low +( (high - low )>>2)，low 和 high 的更新 +1
  * 数据过少体现不出优势，数据过多时对内存空间要求也高
* 跳表
  * 
* 搜索、
* 哈希算法、
* 贪心算法、
* 分治算法、
* 回溯算法、
* 动态规划、
* 字符串匹配算法

#### 复杂度

* 时间复杂度
  * 最坏
  * 最好
  * 平均
* 空间复杂度
* 均摊复杂度

