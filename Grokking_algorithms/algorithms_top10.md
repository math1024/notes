[TOC]



* from geek time 数据结构与算法之美

#### 数据结构

* 数组

  * 数组下标从0开始，历史习惯、减少一次减法运算,数组可以有些存放基础类型、

  * 先标记再删除

    数组根据下标查找 时间复杂度是O(1)

* 链表

  * 单链表
  * 双向链表、循环链表、双向循环链表
  * 实例：LRU、回文
  * tips
    * **指针或引用的含义：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量**
    * 插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏
    * 添加哨兵简化代码
    * 边界条件
      * 如果链表为空时，代码是否能正常工作？
      * 如果链表只包含一个结点时，代码是否能正常工作？
      * 如果链表只包含两个结点时，代码是否能正常工作？
      * 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
    * 画图、多加练习
  * 实例：单链表反转、链表中环的检测、两个有序的链表合并删除、链表倒数第 n 个结点、求链表的中间结点

* 栈

  * 数组实现-顺序栈、链表实现-链式栈
  * 讨论空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间
  * 实例：括号匹配、表达式求值、浏览器前进后退功能模拟，两个栈或双向链表

* 队列

  * 同样数组实现-顺序队列、链表实现-链式队列，数据搬移操作引用循环队列
  * 循环队列的实现注意队满`(tail+1)%n=head`和队空`head == tail`的判断
  * 阻塞队列 生产者-消费者
  * 并发队列
  * 对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队，注意队列的长度

* 散列表、

* 二叉树、

* 堆、

* 跳表、

* 图、

* Trie 树

#### 算法

* 递归
  * 循环体、子问题、终止条件
  * 需要注意的两个问题：堆栈溢出、重复计算，同时也应注意空间复杂度的增长
  * 限制递归深度，重写调用栈
* 排序
  * 如何分析排序算法
    * 执行效率
    * 内存消耗
    * 稳定性
  * 有序度
  * 冒泡排序、插入排序、选择排序、希尔排序
* 二分查找
  * 有序数组，比较耗时多更适宜
  * 循环退出条件<=、mid 的取值 low +( (high - low )>>2)，low 和 high 的更新 +1
* 搜索、
* 哈希算法、
* 贪心算法、
* 分治算法、
* 回溯算法、
* 动态规划、
* 字符串匹配算法

#### 复杂度

* 时间复杂度
  * 最坏
  * 最好
  * 平均
* 空间复杂度
* 均摊复杂度

